// Last Modified : 16 Feb 2024
// This code is developed by Tribhuban Parida.
// It takes the Trento-generated profile as input
// and converts it to the music-compatible input file.
// This code also averages over multiple initial 
// configurations generated by Trento and prepares an
// event-averaged initial condition.


#include <iostream>
#include <fstream>
#include <string>
#include <unordered_map> // For storing variables
#include <stdexcept> // For std::invalid_argument
#include <sstream>
#include <cmath>

using std::cout ;
using std::endl ;


// Trim function to remove leading and trailing whitespace
std::string trim(const std::string& str) {
    size_t first = str.find_first_not_of(' ');
    if (std::string::npos == first) {
        return str;
    }
    size_t last = str.find_last_not_of(' ');
    return str.substr(first, (last - first + 1));

}

// Function to create a 2D dynamic array
double** create2DArray(int rows, int cols) {
    double** array = new double*[rows];
    
    for (int i = 0; i < rows; ++i) {
        array[i] = new double[cols];
    }
    
    return array;
}

// Function to delete a 2D dynamic array
void delete2DArray(double** array, int rows) {
    for (int i = 0; i < rows; ++i) {
        delete[] array[i];
    }
    
    delete[] array;
}


void get_nearest_cell_index( double grid_max, double grid_step, double xx, double yy, int& ix, int& iy ){
  ix =  ceil( ( xx - (-grid_max ) ) / grid_step ) ; 
  iy =  ceil( ( yy - (-grid_max ) ) / grid_step ) ; 
}




// The main function
int main(int argc, char *argv[]) {

    // ############################### //
    // #####      Block - 0      ##### //
    // ############################### //

    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] 
           << " <file1 (trento config file)> "
            <<" <file2 (trento output folder of profile configurations)>"
             << std::endl;
        return 1;
    }

    // Extract file paths from command line arguments
    std::string file1_path = argv[1];
    std::string file2_path = argv[2];

    // Check if the first file exists
    std::ifstream file1(file1_path);
    if (!file1.is_open()) {
        std::cerr << "Error: File '" << file1_path 
            << "' does not exist." << std::endl;
        return 1;
    }
    file1.close();

    // Check if the second file exists
    std::ifstream file2(file2_path);
    if (!file2.is_open()) {
        std::cerr << "Error: File '" << file2_path 
            << "' does not exist." << std::endl;
        return 1;
    }
    file2.close();

    // Both files exist, do something..
    std::cout << "all trento information files exist ..." 
               << std::endl;





    // ############################### //
    // #####      Block - 1      ##### //
    // ############################### //


    // Read the parameter file of trento
    std::string config_file_path = file1_path ; 
    std::ifstream config_file(config_file_path);
    if (!config_file.is_open()) {
        std::cerr << "Error: Unable to open configuration file '" 
              << config_file_path << "'." 
                << std::endl;
        return 1;
    }

    // Variables to store configuration
    std::unordered_map<std::string, std::string> config_vars;

    std::string line;
    while (std::getline(config_file, line)) {

        // Trim the line to remove leading and trailing whitespace
        line = trim(line);
        
        if(line.empty()) {
          continue;
        }

        if (line[0] == '#') {
          continue;
        }

        // Find position of '='
        size_t pos = line.find('=');
        if (pos != std::string::npos) {
            // Extract variable name and value
            std::string var_name = trim(line.substr(0, pos));
            std::string var_value = trim(line.substr(pos + 1));
            // Store in map
            config_vars[var_name] = var_value;
        }
    }
    config_file.close();

    // Access the variables
    double grid_max  = -1 ; 
    double grid_step = -1 ; 

    grid_max = std::stod(config_vars["grid-max"]);
    grid_step = std::stod(config_vars["grid-step"]);
    int Nevents = std::stod(config_vars["number-events"]);
 
    std::cout << "grid_max: " << grid_max << std::endl;
    std::cout << "grid_step: " << grid_step << std::endl;
    std::cout << "number-events: " << Nevents << std::endl;

    if( grid_max < 0 || grid_step < 0 ){
      std::cout << "grid max and grid step is wrong ..." << endl ; 
    }

    // reading trento parameter file completed ...





    // ############################### //
    // #####        Block -2     ##### //
    // ############################### //

    // Create your own grid according to trento parameter file 
    int grid_N = ( 2.000001 * grid_max ) / grid_step + 1 ; 
    std::cout << "grid_N: " << grid_N << std::endl;    


    double** xx = create2DArray(grid_N, grid_N);
    double** yy = create2DArray(grid_N, grid_N);
    double** ee = create2DArray(grid_N, grid_N);
    double** ee_av = create2DArray(grid_N, grid_N);
    for(int ix=0; ix<grid_N; ix++){
      for(int iy=0; iy<grid_N; iy++){
        xx[ix][iy] = -grid_max + ix * grid_step  ; 
        yy[ix][iy] = -grid_max + iy * grid_step ; 
        ee[ix][iy] = 0 ; 
        ee_av[ix][iy] = 0 ; 
      }
    }


    // I believe that, in the below way trento writes
    // and hence I am reading accordingly.
    // change it if you think differently !!! 

    std::ifstream ifile;
    std::ofstream out_file;
    std::stringstream output_filename;
    std::string temp_num_str ; 


    int XX = 0;
    long long temp = Nevents;
    // Counting the number of digits in N
    while (temp != 0) {
        temp /= 10;
        XX++;
    }

    // Looping from 0 to N-1 ( read the files EbE )
    for (long long ievnts = 0; ievnts < Nevents; ++ievnts) {
        std::string num_str = std::to_string(ievnts);
        if (Nevents%10 == 0 ){
          temp_num_str = std::string(XX-num_str.length()-1, '0') + num_str ;
          num_str = file2_path + '/' + std::string(XX-num_str.length()-1, '0') + num_str; }
        else{
          temp_num_str = std::string(XX-num_str.length(), '0') + num_str ;
          num_str = file2_path + '/' + std::string(XX-num_str.length(), '0') + num_str; }
        num_str += ".dat";
        //std::cout << num_str << std::endl;
        ifile.open(num_str);
        if(!ifile){
          std::cout << num_str << "  file not found ... " 
                      << std::endl;
          exit(1);
        }
        else{
          //std::cout << num_str << "  exist ..."<< std::endl;
        }

       // note that the loop goes from 0 to grid_N-1
       for (int ix = 0; ix < grid_N-1; ++ix) {
         for (int iy = 0; iy < grid_N-1; ++iy) {
            ifile >> ee[ix][iy] ; 
         }
       }

       ifile.close() ; 

       // create the music input version
      output_filename.str("");
      output_filename << file2_path << "/music_input_" << temp_num_str ;
      output_filename << ".dat";
      out_file.open(output_filename.str().c_str(), std::ios::out);
      out_file <<"#"<<"\t"<<"Trento_IC"<<"\t"<<"1"<<"\t"<<"neta="
               <<"\t"<<"1"<<"\t"<<"nx="<<"\t"<<grid_N<<"\t"<<"ny="
               <<"\t"<<grid_N <<"\t"<<"deta="<<"\t"<<"0.1"<<"\t"<<"dx="
               <<"\t"<<grid_step<<"\t"<<"dy="<<"\t"<<grid_step<<endl;
       double xcm = 0 ; double ycm = 0 ; double den_esum = 0 ; 
       for (int ix = 0; ix < grid_N; ++ix) {
         for (int iy = 0; iy < grid_N; ++iy) {
           xcm += xx[ix][iy] * ee[ix][iy] ; 
           ycm += yy[ix][iy] * ee[ix][iy] ; 
           den_esum += ee[ix][iy] ; 
           out_file << "0" << "\t" << xx[ix][iy] << "\t" << yy[ix][iy] << "\t" << ee[ix][iy]   
               << "\t" << "1" << "\t" << "0" << "\t" << "0" << "\t" << "0"
               << "\t" << "0" << "\t" << "0" << "\t" << "0" << endl ;
         }
       }
       out_file.close() ;
       cout << "EventID : " << ievnts << ",   xcm = " 
             << xcm / den_esum << "  ycm = "
              << ycm / den_esum << endl ; 

       xcm /= den_esum ; 
       ycm /= den_esum ; 

      // calculate the second order participant plane angle //
      double numsin = 0 ; 
      double numcos = 0 ; 
      double denomi = 0 ; 
      for (int iy = 0; iy < grid_N; ++iy) {
        for (int ix = 0; ix < grid_N; ++ix) {
          double rr = sqrt( (xx[ix][iy]-xcm) * (xx[ix][iy]-xcm) + (yy[ix][iy]-ycm)*(yy[ix][iy]-ycm) ) ;
          double ph = atan2((yy[ix][iy]-ycm),(xx[ix][iy]-xcm)) ;  
          numsin += pow(rr,2) * sin(2*ph) * ee[ix][iy] ; 
          numcos += pow(rr,2) * cos(2*ph) * ee[ix][iy] ; 
          denomi += pow(rr,2) * ee[ix][iy] ; 
        }
      }
      double part_pl = 0.5 * atan2( -1 * numsin/denomi , -1 * numcos/denomi ) ; 
      cout << "2nd order participant plane angle = " << part_pl << endl ; 
      cout << "  " << endl ; 


      // fill to calculate event average profile
      // performing the smearing after shifting to CM = (0,0)
      // and rotating by second order participant plane angle.
      double sigma_perp = 0.2 ; 
      for (int iy = 0; iy < grid_N; ++iy) {
        for (int ix = 0; ix < grid_N; ++ix) {
          if(fabs(ee[ix][iy])<0.00001)
              continue ; 
          double contributors_x =  cos(part_pl) * (xx[ix][iy]-xcm) + sin(part_pl) * (yy[ix][iy]-ycm) ; 
          double contributors_y = -sin(part_pl) * (xx[ix][iy]-xcm) + cos(part_pl) * (yy[ix][iy]-ycm) ;
          double contributors_e = ee[ix][iy] ; 

          int upper_index_x, upper_index_y ; 
          get_nearest_cell_index( grid_max, grid_step, 
               contributors_x + 4 * sigma_perp , contributors_y + 4 * sigma_perp ,
               upper_index_x, upper_index_y ) ; 
          int lower_index_x, lower_index_y ;  
          get_nearest_cell_index( grid_max, grid_step, 
               contributors_x - 4 * sigma_perp , contributors_y - 4 * sigma_perp ,
               lower_index_x, lower_index_y ) ;

          for(int ixx = lower_index_x ; ixx < upper_index_x ; ixx++ ){
             for(int iyy = lower_index_y ; iyy < upper_index_y ; iyy++ ){

                 if( ixx < 3 || iyy < 3 ){
                    continue ; }
                 if( ixx > (grid_N - 3) || iyy > (grid_N - 3) ){
                    continue ; }
                 
                 double grid_x = xx[ixx][iyy] ; 
                 double grid_y = yy[ixx][iyy] ;
	         double weight = 0.25 * contributors_e * ( -erf( (grid_x - grid_step / 2 - contributors_x) / sqrt(2) / sigma_perp ) + 
		        erf((grid_x + grid_step / 2 - contributors_x) / sqrt(2) / sigma_perp) )
	                 * ( -erf( (grid_y - grid_step / 2 - contributors_y) / sqrt(2) / sigma_perp ) + 
		         erf((grid_y + grid_step / 2 - contributors_y) / sqrt(2) / sigma_perp) ) ;
	         ee_av[ixx][iyy] += weight ; 
            } // iyy loop
          } // ixx loop

        } // ix loop
      } // iy loop

    } // ievnts

    


    // write the event averaged profile //
    for (int iy = 0; iy < grid_N; ++iy) {
      for (int ix = 0; ix < grid_N; ++ix) {
        ee_av[ix][iy] /= Nevents ; 
      }
    }

    output_filename.str("");
    output_filename << file2_path << "/event_average_initial_profile_for_music_input_" << Nevents ;
    output_filename << ".dat";
    out_file.open(output_filename.str().c_str(), std::ios::out);
    out_file <<"#"<<"\t"<<"Trento_IC"<<"\t"<<"1"<<"\t"<<"neta="
             <<"\t"<<"1"<<"\t"<<"nx="<<"\t"<<grid_N<<"\t"<<"ny="
             <<"\t"<<grid_N <<"\t"<<"deta="<<"\t"<<"0.1"<<"\t"<<"dx="
             <<"\t"<<grid_step<<"\t"<<"dy="<<"\t"<<grid_step<<endl;
     double xcm = 0 ; double ycm = 0 ; double den_esum = 0 ; 
     for (int ix = 0; ix < grid_N; ++ix) {
       for (int iy = 0; iy < grid_N; ++iy) {
         xcm += xx[ix][iy] * ee_av[ix][iy] ; 
         ycm += yy[ix][iy] * ee_av[ix][iy] ; 
         den_esum += ee_av[ix][iy] ; 
         out_file << "0" << "\t" << xx[ix][iy] << "\t" << yy[ix][iy] << "\t" << ee_av[ix][iy]   
             << "\t" << "1" << "\t" << "0" << "\t" << "0" << "\t" << "0"
             << "\t" << "0" << "\t" << "0" << "\t" << "0" << endl ;
       }
     }
     out_file.close() ;
     cout << "Event avergaed : " << "   xcm = " 
           << xcm / den_esum << "  ycm = "
            << ycm / den_esum << endl ; 




    delete2DArray(xx, grid_N);
    delete2DArray(yy, grid_N);
    delete2DArray(ee, grid_N);
    delete2DArray(ee_av, grid_N);

    return 0;
}







